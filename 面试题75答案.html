<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>面试题75答案</title>    
</head>
<body>
	<h1>75 前40个元字符的用法及举例。 </h1>
	<pre>	
一 \	
   将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
    <script type="text/javascript">
         //1 \在正则字面量中不需要转义，在字符串中需要转义
		   var reg1 = /\c/;
		   var reg2 = /\\c/;
		   var reg3 = /\\/;
		   console.log(reg1.test("\\c"));//true
		   console.log(reg2.test("\\c"));//true
		   console.log(reg3.test("\\"));//true
		 //2 用构造函数创建正则，\不需要转义 
		   var reg4 = new RegExp("\c");
		   var reg5 = new RegExp("\\c");
		   var reg6 = new RegExp("\\");
		   var reg7 = new RegExp("\\\\");
		   console.log(reg4.test("\\c"));//true
		   console.log(reg5.test("\\c"));//true
		   //console.log(reg6.test("\\"));//报错，Invalid regular expression: /\/: \ at end of pattern(…)
		   console.log(reg7.test("\\\\"));//true
		 //3 只有\时语法错误,无法通过编辑
		   //var reg8 = /\/;
		   //var reg9 = new RegExp("\");
   	    //4 其他元字符需要转义的会在后面介绍   	     
    </script>

    	

二 ^	
  匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
  <script type="text/javascript">
  	  // 1 当^位于正则的起始位置时，表示字符必须以^后的内容开头
  	     var reg1 = /^a/
  	     console.log(reg1.test("ab"));//true
  	     console.log(reg1.test("ba"));//fasle
  	     var reg2 = /^a\nb/
  	     console.log(reg2.test("a\na")); //false
  	     console.log(reg2.test("a\nb")); //true
         var reg3 = /^a\nb/m
  	     console.log(reg3.test("a\na")); //false
  	     console.log(reg3.test("a\nb")); //true
  	  // 2 当^位于正则的非起始位置时，需要转义才能匹配原来的字符
  	     var reg4 = /a^/;
   		 var reg5 = /a\^/;
   		 console.log(reg4.test("a^"));//false
   		 console.log(reg5.test("a^"));//true
     // 3 当^位于[]内的第一个位置时，表示取反,不能出现^后面的字符
         var reg6 = /[^abc]/;
         console.log(reg6.test("a"));//false
         console.log(reg6.test("b"));//false
         console.log(reg6.test("c"));//false
         console.log(reg6.test("d"));//true
     // 4 当^位于[]内的非第一个元素时，表示^本身
         var reg7 = /[a^b]/;
         console.log(reg7.test("a"));//true
         console.log(reg7.test("b"));//true
         console.log(reg7.test("^"));//true
         console.log(reg7.test("c"));//false
  </script>

三 $	
  匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
  <script type="text/javascript">
  	 // 1 当$位于正则的结束位置时，表示字符必须以$前的内容结尾
  	     var reg1 = /a$/
  	     console.log(reg1.test("ab"));//false
  	     console.log(reg1.test("ba"));//true
  	     var reg2 = /a\nb$/
  	     console.log(reg2.test("a\na")); //false
  	     console.log(reg2.test("a\nb")); //true
         var reg3 = /a\nb$/m
  	     console.log(reg3.test("a\na")); //false
  	     console.log(reg3.test("a\nb")); //true
  	  // 2 当^位于正则的非起始位置时，需要转义才能匹配原来的字符
  	     var reg4 = /$a/;
   		 var reg5 = /\$a/;
   		 console.log(reg4.test("$a"));//false
   		 console.log(reg5.test("$a"));//true
  </script>

四 *	
  匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。
  <script type="text/javascript">
  	// 1 当*位于正则的非起始位置时，表示*前面的字符可以出现0次或多次
  	     var reg1 = /a*/
  	     console.log(reg1.test("cxh"));//true
  	     console.log(reg1.test("a"));//true
  	     console.log(reg1.test("aa"));//true  	    
  	  // 2 当*位于正则的起始位置是表示多行注释，需要转义表达原来字符
  	     //var reg2 = /*a/;
   		 var reg2 = /\*a/;
   		 console.log(reg2.test("*a"));//true
   	  // 3 当用构造函数定义正则，且当*位于正则的起始位置是表示多行注释，需要双重转义表达原来字符
   	     //var reg3 = new RegExp("*a");
   	     //var reg4 = new RegExp("\*a");
   	     var reg5 = new RegExp("\\*a");   	     
   		 //console.log(reg3.test("*a"));//报错，Invalid regular expression: /*a/: Nothing to repeat(…)
   		 //console.log(reg4.test("*a"));//报错，Invalid regular expression: /*a/: Nothing to repeat(…)
   		 console.log(reg5.test("*a"));//true
  </script>

五 +	
  匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
    <script type="text/javascript">
  	// 1 当*位于正则的非起始位置时，表示*前面的字符可以出现0次或多次
  	     var reg1 = /a+/
  	     console.log(reg1.test("cxh"));//false
  	     console.log(reg1.test("a"));//true
  	     console.log(reg1.test("aa"));//true  	    
  	  // 2 当*位于正则的起始位置没有意义，需要转义表达原来字符
  	     //var reg2 = /*a/;
   		 var reg2 = /\+a/;
   		 console.log(reg2.test("*a"));//true
   	  // 3 当用构造函数定义正则，且当*位于正则的起始位置时没有意义，需要双重转义表达原来字符
   	     //var reg3 = new RegExp("+a");
   	     //var reg4 = new RegExp("\+a");
   	     var reg5 = new RegExp("\\+a");   	     
   		 //console.log(reg3.test("+a"));//报错，Invalid regular expression: /+a/: Nothing to repeat(…)
   		 //console.log(reg4.test("+a"));//报错，Invalid regular expression: /+a/: Nothing to repeat(…)
   		 console.log(reg5.test("+a"));//true
  </script>

六 ?	
  匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于{0,1}。
  <script type="text/javascript">
  	// 1 当*位于正则的非起始位置时，表示*前面的字符可以出现0次或多次
  	     var reg1 = /a?b/
  	     console.log(reg1.test("cxhb"));//true
  	     console.log(reg1.test("ab"));//true
  	     console.log(reg1.test("b"));//true  	    
  	  // 2 当*位于正则的起始位置没有意义，需要转义表达原来字符
  	     //var reg2 = /?a/;
   		 var reg2 = /\?a/;
   		 console.log(reg2.test("?a"));//true
   	  // 3 当用构造函数定义正则，且当*位于正则的起始位置时灭有意义i，需要双重转义表达原来字符
   	     //var reg3 = new RegExp("?a");
   	     //var reg4 = new RegExp("\?a");
   	     var reg5 = new RegExp("\\?a");   	     
   		 //console.log(reg3.test("?a"));//报错，Invalid regular expression: /?a/: Nothing to repeat(…)
   		 //console.log(reg4.test("?a"));//报错，Invalid regular expression: /?a/: Nothing to repeat(…)
   		 console.log(reg5.test("?a"));//true
  </script>

七 {n}	
  n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
  <script type="text/javascript">
  	// 1 当{n}位于正则的非起始位置时，表示{n}前面的字符可以出现n次
  	     var reg1 = /ab{2}c/
  	     console.log(reg1.test("abc"));//false
  	     console.log(reg1.test("ac"));//fasle
  	     console.log(reg1.test("abbc"));//true
  	     console.log(reg1.test("abbbc"));//false  	       	    
  	  // 2 当{n}位于正则的起始位置时没有意义，需要转义表达原来字符
  	     //var reg2 = /{2}a/; 
   		 var reg3 = /\{2}a/;
   		 //console.log(reg2.test("{2}a"));//报错，Invalid regular expression: /{2}a/: Nothing to repeat(…)
   		 console.log(reg3.test("{2}a"));//true
   	  // 3 当用构造函数定义正则，且当{n}位于正则的起始位置时没有意义，需要双重转义表达原来字符
   	     //var reg4 = new RegExp("{2}a");
   	     //var reg5 = new RegExp("\{2}a");
   	     var reg5 = new RegExp("\\{2}a");   	     
   		 //console.log(reg3.test("{2}a"));//报错，Invalid regular expression: /{2}a/: Nothing to repeat(…)
   		 //console.log(reg4.test("{2}a"));//报错，Invalid regular expression: /{2}a/: Nothing to repeat(…)
   		 console.log(reg5.test("{2}a"));//true
  </script>


八 {n,}	
  n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
  <script type="text/javascript">
  	// 1 当{n,}位于正则的非起始位置时，表示{n}前面的字符至少出现n次
  	     var reg1 = /ab{2,}c/
  	     console.log(reg1.test("abc"));//false
  	     console.log(reg1.test("ac"));//fasle
  	     console.log(reg1.test("abbc"));//true 
  	     console.log(reg1.test("abbbc"));//true  
  	      console.log(reg1.test("abbbbc"));//true 	  	    
  	  // 2 当{n,}位于正则的起始位置时没有意义，需要转义表达原来字符
  	     //var reg2 = /{2,}a/; 
   		 var reg3 = /\{2,}a/;
   		 //console.log(reg2.test("{2,}a"));//报错，Invalid regular expression: /{2,}a/: Nothing to repeat(…)
   		 console.log(reg3.test("{2,}a"));//true
   	  // 3 当用构造函数定义正则，且当{n,}位于正则的起始位置时没有意义，需要双重转义表达原来字符
   	     //var reg4 = new RegExp("{2,}a");
   	     //var reg5 = new RegExp("\{2,}a");
   	     var reg5 = new RegExp("\\{2,}a");   	     
   		 //console.log(reg3.test("{2,}a"));//报错，Invalid regular expression: /{2,}a/: Nothing to repeat(…)
   		 //console.log(reg4.test("{2,}a"));//报错，Invalid regular expression: /{2,}a/: Nothing to repeat(…)
   		 console.log(reg5.test("{2,}a"));//true
  </script>


九 {n,m}	
  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。如， "o{1,3}" 将匹配 "fooooood"中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
   <script type="text/javascript">
  	// 1 当{n,m}位于正则的非起始位置时，表示{n}前面的字符至出现n到m
  	     var reg1 = /ab{2,3}c/
  	     console.log(reg1.test("abc"));//false
  	     console.log(reg1.test("ac"));//fasle
  	     console.log(reg1.test("abbc"));//true 
  	      console.log(reg1.test("abbbc"));//true  
  	       console.log(reg1.test("abbbbc"));//false 	  	    
  	  // 2 当{n,m}位于正则的起始位置时没有意义，需要转义表达原来字符
  	     //var reg2 = /{2,3}a/; 
   		 var reg3 = /\{2,3}a/;
   		 //console.log(reg2.test("{2,3}a"));//报错，Invalid regular expression: /{2,3}a/: Nothing to repeat(…)
   		 console.log(reg3.test("{2,3}a"));//true
   	  // 3 当用构造函数定义正则，且当{2,3}位于正则的起始位置时没有意义，需要双重转义表达原来字符
   	     //var reg4 = new RegExp("{2,3}a");
   	     //var reg5 = new RegExp("\{2,3}a");
   	     var reg6 = new RegExp("\\{2,3}a");   	     
   		 //console.log(reg3.test("{2,3}a"));//报错，Invalid regular expression: /{2,3}a/: Nothing to repeat(…)
   		 //console.log(reg4.test("{2,3}a"));//报错，Invalid regular expression: /{2,3}a/: Nothing to repeat(…)
   		 console.log(reg6.test("{2,3}a"));//true
  </script>


十 ?	
  当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。	
  <script type="text/javascript">
  	// 1 当+后面不加？时，默认贪婪模式
  	     var reg1 = /ab+/
  	     console.log("abbc".match(reg1));//["abb", index: 0, input: "abbc"]  	        
  	 // 2 当+后面加？时，修改为非贪婪模式
  	     var reg2 = /ab+?/
  	     console.log("abbc".match(reg2));//["ab", index: 0, input: "abbc"]   
  	 // 3 当用构造函数定义正则，且当+?位于正则的起始位置时没有意义，需要双重转义表达原来字符
   	     //var reg3 = new RegExp("+?a");
   	     //var reg4 = new RegExp("\+?a");
   	     var reg5 = new RegExp("\\+?a");   	     
   		 //console.log(reg3.test("+?a"));//报错，Invalid regular expression: /+?a/: Nothing to repeat(…)
   		 //console.log(reg4.test("{+?a"));//报错，Invalid regular expression: /+?a/: Nothing to repeat(…)
   		 console.log(reg5.test("+?a"));//true 	  

  </script>	

十一 .	
    匹配除 "\n" 或"\r"之外的任何单个字符。
    <script type="text/javascript">
    	var reg1 = /./;
    	var reg2 = /\./;
    	console.log(reg1.test("\n"));//false
    	console.log(reg1.test("\r"));//false
    	console.log(reg1.test("\n\r"));//false
    	console.log(reg1.test("\r\n"));//false
    	console.log(reg1.test("\t"));//true
    	console.log(reg1.test("\b"));//true
    	console.log(reg1.test("\s"));//true
    	console.log(reg1.test("\w"));//true
    	console.log(reg1.test("\d"));//true
    	console.log(reg1.test("[a-zA-Z]"));//true
    	console.log(reg1.test("."));//true
    	console.log(reg2.test("."));//true
    </script>

十二 (pattern)	
    匹配pattern 并获取这一匹配。在JScript 中则使用 $1…$9 属性。要匹配圆括号字符，请使用 '\(' 或'\)'。踹
    补充知识：
    1 RegExp实例的属性
      global:布尔值，表示是否设置了g标识
      ignoreCase：布尔值，表示是否设置了i标识
      lastIndex：整数，表示开始搜索下一个匹配项的字符串位置，从0算起
      multiline：布尔值，表示是否设置了m标志
      source：正则表达式的字符串表示，按照字面量形式而非构造函中的字符串模式
    2 替换字符串可以插入下面的特殊变量名：
	    //$n 既可以作为replace方法第二个参数字符串中的值"&1"形式，又可以构造函数的属性RegExp.$1形式获取
	    $n	假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。
	    //&&、$&、$`、$'只能作为replace方法第二个参数字符串中的值"$$"、"$&"、"$`"、"$'"形式获取
	    $$	插入一个 "$"。
		$&	插入匹配的子串。
		$`	插入当前匹配的子串左边的内容。
		$'	插入当前匹配的子串右边的内容。
		//$_只能以构造函数属性RegExp.$_形式获取
		$_  最近一次要匹配的字符串
		//$+和$*浏览器未实现
		$+  最近一次匹配的捕获组
		$*  布尔值，表示所有表达式是否都使用多行模式
    <script type="text/javascript">
    	var reg1=/(\d)[a-z]/g;
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["1a", "1", index: 4, input: "cxh.1a.2b.3c.kn"]
    	console.log("cxh.1a.2b.3c.kn".match(reg1));//["1a", "2b", "3c"]
    	var reg2=/\(\d\)[a-z]/g;
    	var reg3=/(\d)([a-z])/g;
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["1a", "1", index: 4, input: "cxh.1a.2b.3c.kn"]
    	console.log(reg1.global,reg1.ignoreCase,reg1.lastIndex,reg1.multiline,reg1.source);//true false 6 false "(\d)[a-z]"
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["2b", "2", index: 7, input: "cxh.1a.2b.3c.kn"]
    	console.log(reg1.global,reg1.ignoreCase,reg1.lastIndex,reg1.multiline,reg1.source);//true false 9 false "(\d)[a-z]"
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["3c", "3", index: 10, input: "cxh.1a.2b.3c.kn"]
    	console.log(reg1.global,reg1.ignoreCase,reg1.lastIndex,reg1.multiline,reg1.source);//true false 12 false "(\d)[a-z]"
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//null,上次lastIndex=12位于字母k前面的.，从字母k前面的.开始索引向后查招找不数字字母的组合。
    	console.log(reg1.global,reg1.ignoreCase,reg1.lastIndex,reg1.multiline,reg1.source);//true false 0 false "(\d)[a-z]"，重写初始化lastIndex=0
    	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["1a", "1", index: 4, input: "cxh.1a.2b.3c.kn"], 开始第二轮匹配
    	console.log(reg1.global,reg1.ignoreCase,reg1.lastIndex,reg1.multiline,reg1.source);//true false 6 false "(\d)[a-z]"
    	console.log(reg2.exec("cxh.1a.2b.3c.kn"));//null
    	console.log(reg2.exec("cxh.(1)a.(2)b.(3)c.kn"));//["(1)a", index: 4, input: "cxh.(1)a.(2)b.(3)c.kn"]
    	console.log("cxh.1a.2b.3c.kn".match(reg1));//["1a", "2b", "3c"]
    	console.log("cxh.1a.2b.3c.kn".replace(reg1,"$1"));//cxh.1.2.3.kn
    	console.log("cxh.1a.2b.3c.kn".replace(reg1,"$$"));//cxh.$.$.$.kn
        console.log("cxh.1a.2b.3c.kn".replace(reg1,"$&"));//xh.1a.2b.3c.kn
        console.log("cxh.1a.2b.3c.kn".replace(reg1,"$`"));//cxh.cxh..cxh.1a..cxh.1a.2b..kn
        console.log("cxh.1a.2b.3c.kn".replace(reg1,"$'"));//cxh..2b.3c.kn..3c.kn..kn.kn         
        console.log("cxh.1a.2b.3c.kn".replace(reg1,"$_"));//cxh.$_.$_.$_.kn
        console.log("cxh.1a.2b.3c.kn".replace(reg1,RegExp.$_));//cxh.cxh.1a.2b.3c.kn.cxh.1a.2b.3c.kn.cxh.1a.2b.3c.kn.kn
        var result1 = "cxh.1a.2b.3c.kn".replace(reg1,function(){
       	    console.log(RegExp.$1);
       	    /*
       	    	3
       	    	3
       	    	3
       	    */  
       	    return RegExp.$1;
       });//"cxh.3.3.3.kn"
         var result2 = "cxh.1a.2b.3c.kn".replace(reg1,function(){
       	    console.log(arguments[0],arguments[1],arguments[2],arguments[3]);
       	    /* 匹配的字符串   匹配次数  在原字符中索引    原字符串
       	    	1a 				1 		4   			cxh.1a.2b.3c.kn 
       	    	2b 				2 		7    			cxh.1a.2b.3c.kn 
       	    	3c 				3 		10   			cxh.1a.2b.3c.kn 
       	    */  
       	    return arguments[0]+"c";
       });//"cxh.1ac.2bc.3cc.kn"
        console.log("cxh.1a.2b.3c.kn".replace(reg1,"$*"));//cxh..2b.3c.kn..3c.kn..kn.kn      
    	console.log("cxh.1a.2b.3c.kn".replace(reg1,"$1"));//cxh.1.2.3.kn
    	console.log("cxh.1a.2b.3c.kn".replace(reg3,"$2$1"));//cxh.a1.b2.c3.kn
    	console.log("cxh.1a.2b.3c.kn".replace(reg3,"$1$2"));//cxh.1a.2b.3c.kn
    </script>

十三 (?:pattern)	
     匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用"或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比'industry|industries' 更简略的表达式。
     <script type="text/javascript">
         //括号内加上?:后，使用exec和repalce方法无法获取分组
     	 var reg1 = /(\d)[a-z]/;
     	 var reg2 = /(?:\d)[a-z]/;
     	 console.log(reg1.exec("cxh.1a.2b.3c"));//["1a", "1", index: 4, input: "cxh.1a.2b.3c"]
     	 console.log(reg2.exec("cxh.1a.2b.3c"));//["1a", index: 4, input: "cxh.1a.2b.3c"]
     	 console.log("cxh.1a.2b.3c".replace(reg1,"$1"));//cxh.1.2b.3c
     	 console.log("cxh.1a.2b.3c".replace(reg2,"$1"));//cxh.$1.2b.3c
     </script>
十四 (?=pattern)	 
     正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， 'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的"Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
     <script type="text/javascript">
     	var reg1=/[a-z]+\.(\d)/g;
     	console.log(reg1.exec("cxh.1a.2b.3c.kn"));//["cxh.1", "1", index: 0, input: "cxh.1a.2b.3c.kn"]
     	//正向预查，不包含(?=pattern)匹配到的字符，比如括号内匹配一个数字，下面就忽略了这个数字    	
    	var reg2=/[a-z]+\.(?=\d)/g;
    	console.log(reg2.exec("cxh.1a.2b.3c.kn"));//["cxh.", index: 0, input: "cxh.1a.2b.3c.kn"]    	
     </script>
 十五 (?!pattern)	
     负向预查，在任何不匹配的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 
     2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
     <script type="text/javascript">
     	var reg1=/[a-z]+\.(\d)/g;
     	console.log(reg1.exec("cxh.1a.2b.3d.kn"));//["cxh.1", "1", index: 0, input: "cxh.1a.2b.3d.kn"]
     	//负向预查，前面的字符字母.开头，点后面的字母不能是数字，只有d.后面的字母不是数字，所以d.符合    	
    	var reg2=/[a-z]+\.(?!\d)/g;
    	console.log(reg2.exec("cxh.1a.2b.3d.kn"));//["d.", index: 11, input: "cxh.1a.2b.3d.kn"]	
     </script>
 十六 x|y	
     匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
     <script type="text/javascript">
     	var reg1 = /(k|f)ind/;
     	console.log(reg1.test("kind"));//true
     	console.log(reg1.test("find"));//true
     	console.log(reg1.test("wind"));//false
     </script>
 十七 [xyz]	
    字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
    <script type="text/javascript">
     	var reg1 = /[fkw]ind/;
     	console.log(reg1.test("kind"));//true
     	console.log(reg1.test("find"));//true
     	console.log(reg1.test("wind"));//true
     	console.log(reg1.test("mind"));//false
     </script>
十八 [^xyz]	
     负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。
       <script type="text/javascript">
     	var reg1 = /[^fkw]ind/;
     	console.log(reg1.test("kind"));//false
     	console.log(reg1.test("find"));//false
     	console.log(reg1.test("wind"));//false
     	console.log(reg1.test("mind"));//true
     </script>
十九 [a-z]	
    字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。例如:[a-z]   [A-Z]   [0-9]
      <script type="text/javascript">
        //1 匹配小写字母
     	var reg1 = /^[a-z]$/;
     	console.log(reg1.test("a"));//true
     	console.log(reg1.test("b"));//true
     	console.log(reg1.test("A"));//false
     	console.log(reg1.test("B"));//false
     	//2 匹配大写字母
     	var reg2 = /^[A-Z]$/;
     	console.log(reg2.test("a"));//false
     	console.log(reg2.test("b"));//false
     	console.log(reg2.test("A"));//true
     	console.log(reg2.test("B"));//true
     	//3 匹配大小写字母写法1
     	var reg3 = /^[A-z]$/;
     	console.log(reg3.test("a"));//true
     	console.log(reg3.test("b"));//true
     	console.log(reg3.test("A"));//true
     	(console.logreg3.test("B"));//true
     	console.log(reg3.test("1"));//false
        //4 匹配大小写字母写法2
     	var reg4 = /^[A-Za-z]$/;
     	console.log(reg4.test("a"));//true
     	console.log(reg4.test("b"));//true
     	console.log(reg4.test("A"));//true
     	console.log(reg4.test("B"));//true
     	console.log(reg4.test("1"));//false
     	//5 匹配小于10的非负整数
     	var reg5 = /^[0-9]/$;
     	console.log(reg5.test("0"));//true
     	console.log(reg5.test("1"));//true
     	console.log(reg5.test("2"));//true
     	console.log(reg5.test("9"));//true
     	console.log(reg3.test("10"));//false
     	//6 匹配大于等于10小于100两位正整数
     	var reg6 = /^[1-9][0-9]$/;
     	console.log(reg6.test("10"));//true
     	console.log(reg6.test("52"));//true
     	console.log(reg6.test("88"));//true
     	console.log(reg6.test("99"));//true
     	console.log(reg6.test("100"));//false
     	console.log(reg6.test("9"));//fals
        //7 匹配大于10小于100正整数的错误写法
        var reg7 = /^[10-99]$/;//此正则的含义是匹配1或者0-9之间的正数或者9，等价于匹配0-9之间的整数。
     	console.log(reg7.test("10"));//true
     	console.log(reg7.test("52"));//true
     	console.log(reg7.test("88"));//true
     	console.log(reg7.test("99"));//true
     	console.log(reg7.test("100"));//false
     	console.log(reg7.test("9"));//true6
     </script>
二十 [^a-z]	
     负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 
           <script type="text/javascript">
        //1 匹配f非小写字母
     	var reg1 = /^[^a-z]$/;
     	console.log(reg1.test("a"));//false
     	console.log(reg1.test("b"));//false
     	console.log(reg1.test("A"));//true
     	console.log(reg1.test("B"));//true
     	//2 匹配非大写字母
     	var reg2 = /^[^A-Z]$/;
     	console.log(reg2.test("a"));//true
     	console.log(reg2.test("b"));//true
     	console.log(reg2.test("A"));//false
     	console.log(reg2.test("B"));//false
     	//3 匹配非字母写法1
     	var reg3 = /^[^A-z]$/;
     	console.log(reg3.test("a"));//false
     	console.log(reg3.test("b"));//false
     	console.log(reg3.test("A"));//false
     	console.log(reg3.test("B"));//false
     	console.log(reg3.test("1"));//true
        //4 匹配非字母写法2
     	var reg4 = /^[^A-Za-z]$/;
     	console.log(reg4.test("a"));//false
     	console.log(reg4.test("b"));//false
     	console.log(reg4.test("A"));//false
     	console.log(reg4.test("B"));//false
     	console.log(reg4.test("1"));//true
     	//5 匹配1位非数字字符
     	var reg5 = /^[^0-9]$/;
     	console.log(reg5.test("0"));//false
     	console.log(reg5.test("1"));//false
     	console.log(reg5.test("2"));//false
     	console.log(reg5.test("9"));//false
     	console.log(reg5.test("10"));//false，两位数
     	console.log(reg5.test("a"));//true
     	//6 两位非数字字符
     	var reg6 = /^[^0-9][^0-9]$/;
     	console.log(reg6.test("10"));//false
     	console.log(reg6.test("99"));//false
     	console.log(reg6.test("100"));//false
     	console.log(reg6.test("1"));//false
     	console.log(reg6.test("c_"));//true
     	console.log(reg6.test("ab"));//true
        //7 匹配1位非数字字符
      var reg7 = /^[^10-99]$/;//此正则的含义是不匹配1或者不匹配0-9之间的正数或者不匹配9，等价于不匹配数字。     
     	console.log(reg7.test("0"));//false
     	console.log(reg7.test("1"));//false
     	console.log(reg7.test("2"));//false
     	console.log(reg7.test("9"));//false
     	console.log(reg7.test("10"));//false，两位数
     	console.log(reg7.test("a"));//true
     </script>


二十一 \b	
       匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 
       只要不是字母、数字、下划线，其他字符都是边界，字符串的开始位置和结束位置也会 边界。  
       匹配单词边界，也就是字母、数字、下划线与其它字符之间的零距离间隔
       注意:\b本身不占用任何字符
       比如"I love chinese food"等价于"\bI\b \blove\b \bchinese\b \bfood\b"    
       1 数字和不常用字符之间(数字、字母、下划线之外的字符)
         "1&".split(/\b/);//["1", "&"]
       2 字母和不常用字符之间
          "a*".split(/\b/);//["a", "*"]
       3 下滑线和不常用字符之间
          "_$".split(/\b/);//["_", "&"]
       4 字符串的起始位置如果是常用字符，也会形成边界
          /^\b\w+\b$/.test("abc");//true          
       <script type="text/javascript">
            //因为字母、数字和下划线不是边界。            
       		var reg1 =/\b\w+\b/ig;       		
       		console.log("I love chinese food".match(reg1));//["I", "love", "chinese","food"]
       		 //chinese1food整体匹配\w+, 左侧的空壳匹配\b，右侧作为字符的结束位置匹配\b
       		console.log("I love chinese1food".match(reg1));//["I", "love", "chinese1food"]
       		//chinese_food整体匹配\w+, 左侧的空壳匹配\b，右侧作为字符的结束位置匹配\b
       		console.log("I love chinese_food".match(reg1));//["I", "love", "chinese_food"]
       		console.log("I love chinese$food".match(reg1));//["I", "love", "chinese", "food"]
       		console.log("I love chinese的food".match(reg1));//["I", "love", "chinese", "food"]       		
       		var reg2 =/\b[a-z]+\b/ig;
       		console.log("I love chinese food".match(reg2));//["I", "love", "chinese","food"]
       		 //chinese1food整体包含非字母不匹配[a-z]+, chinese右侧是1不匹配\b，food左侧是1不匹配\b
       		console.log("I love chinese1food".match(reg2));//["I", "love"]
       		 //chinese_food整体包含非字母不匹配[a-z]+, 所以无法进行捕获
       		console.log("I love chinese_food".match(reg2));//["I", "love"]
       		console.log("I love chinese$food".match(reg2));//["I", "love", "chinese", "food"]
       		console.log("I love chinese的food".match(reg2));//["I", "love", "chinese", "food"]
       		var reg3 =/\b[a-z]+/ig;
       		console.log("I love chinese food".match(reg3));//["I", "love", "chinese","food"]
       		 //chinese这个单词整体匹配[a-z]+,且左侧为空格匹配\b，满足正则
       		console.log("I love chinese1food".match(reg3));//["I", "love", "chinese"]
       		//chinese这个单词整体匹配[a-z]+,且左侧为空格匹配\b，满足正则
       		console.log("I love chinese_food".match(reg3));//["I", "love", "chinese"]
       		console.log("I love chinese$food".match(reg3));//["I", "love", "chinese", "food"]
       		console.log("I love chinese的food".match(reg3));//["I", "love", "chinese", "food"]
       		var reg4 =/[a-z]+\b/ig;
       		console.log("I love chinese food".match(reg4));//["I", "love", "chinese","food"]
       		 //food这个单词整体匹配[a-z]+,且右侧为空格匹配\b，满足正则
       		console.log("I love chinese1food".match(reg4));//["I", "love", "food"]
       		//food这个单词整体匹配[a-z]+,且右侧侧为空格匹配\b，满足正则
       		console.log("I love chinese_food".match(reg4));//["I", "love", "food"]
       		console.log("I love chinese$food".match(reg4));//["I", "love", "chinese", "food"]
       		console.log("I love chinese的food".match(reg4));//["I", "love", "chinese", "food"]
       </script>
       注意：虽然\W也会匹配非数字、非字母和非下划线,但不要用\W取代\b。
             因为\W不能匹配字符串的开始和结束位置，而且\W会把边界字符连同常用字符一起捕获，即\W会占用字符。
      <script type="text/javascript">
            //因为正则捕获时把love两侧的空格也一起获取了，导致chinese左侧的空格无法再次捕获。     
       		var reg1 =/\W\w+\W/ig;       		
       		console.log("I love chinese food".match(reg1));//[" love "]       	
       		console.log("I love chinese1food".match(reg1));//[" love "]      
       		console.log("I love chinese_food".match(reg1));//[" love "]
       		console.log("I love chinese$food".match(reg1));//[" love "]
       		console.log("I love chinese的food".match(reg1));//[" love "]  
       		 //因为正则捕获时把love两侧的空格也一起获取了，导致chinese左侧的空格无法再次捕获。     		
       		var reg2 =/\W[a-z]+\W/ig;
       		console.log("I love chinese food".match(reg2));//[" love "]        		
       		console.log("I love chinese1food".match(reg2));//[" love "]       		
       		console.log("I love chinese_food".match(reg2));//[" love "]    
       		console.log("I love chinese$food".match(reg2));//[" love "]    
       		console.log("I love chinese的food".match(reg2));//[" love "]    
       		var reg3 =/\W[a-z]+/ig;
       		//因为正则捕获时只捕获单词左侧的\W，对右侧单词不造成影响
       		console.log("I love chinese food".match(reg3));//[" love", " chinese", " food"]
       		 //chinese这个单词整体匹配[a-z]+,且左侧为空格匹配\W，满足正则
       		console.log("I love chinese1food".match(reg3));//[" love", " chinese"]
       		//chinese这个单词整体匹配[a-z]+,且左侧为空格匹配\W，满足正则
       		console.log("I love chinese_food".match(reg3));//[" love", " chinese"]
       		console.log("I love chinese$food".match(reg3));//[" love", " chinese", " food"]
       		console.log("I love chinese的food".match(reg3));//[" love", " chinese", " food"]
       		var reg4 =/[a-z]+\W/ig;
       		//因为正则捕获时只捕获单词右侧的\W，对右侧单词不造成影响
       		console.log("I love chinese food".match(reg4));//["I ", "love ", "chinese "]
       		 //food这个单词整体匹配[a-z]+,且右侧为空格匹配\W，满足正则
       		console.log("I love chinese1food".match(reg4));//["I ", "love "]
       		//food这个单词整体匹配[a-z]+,且右侧侧为空格匹配\W，满足正则
       		console.log("I love chinese_food".match(reg4));//["I ", "love "]
       		console.log("I love chinese$food".match(reg4));//["I ", "love ", "chinese$"]
       		console.log("I love chinese的food".match(reg4));//["I ", "love ", "chinese的"]
       </script>

二十二 \B	
       匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
       匹配非单词边界，也就是字母、数字、下划线之间的零距离间隔
       注意：\B本身不占用字符，
       比如"I love chinese food"等价于"I l\Bo\Bv\Be c\Bh\Bi\Bn\Be\Bs\Be f\Bo\Bo\Bd"
       1 字母与字母之间
         "ab".split(/\B/);//["a", "b"]
       2 字母和数字之间
         "a1".split(/\B/);//"a", "1"]
       3 字母和下划线之间
         "a_".split(/\B/);//"a", "_"]
       4 数字和数字之间
         "12".split(/\B/);//"1", "2"]
       5 数字和下划线之间
         "1_".split(/\B/);//"1", "_"]
       6 下划线和下滑下之间
         "__".split(/\B/);//"_", "_"]
        <script type="text/javascript">
            //因为字母、数字和下划线不是边界。            
       		var reg1 =/\B\w+\B/ig;       		
       		console.log("I love chinese food".match(reg1));//["ov", "hines", "oo"]
       		 //hinese1foo整体匹配\w+,c和h之间匹配\B，o和d之间匹配\B
       		console.log("I love chinese1food".match(reg1));//["ov", "hinese1foo"]
       		//chinese_food整体匹配\w+, 左侧的空壳匹配\b，右侧作为字符的结束位置匹配\b
       		console.log("I love chinese_food".match(reg1));//["ov", "hinese_foo"]
       		console.log("I love chinese$food".match(reg1));//["ov", "hines", "oo"]
       		console.log("I love chinese的food".match(reg1));//["ov", "hines", "oo"]     		
       		var reg2 =/\B\w\B/ig;      
       		//如果字符本身和左右两侧都是数字字母下划线，则匹配。
       		console.log("I love chinese food".match(reg2));//["o", "v", "h", "i", "n", "e", "s", "o", "o"       		 
       		console.log("I love chinese1food".match(reg2));//["o", "v", "h", "i", "n", "e", "s", "e", "1", "f", "o", "o"]       	
       		console.log("I love chinese_food".match(reg2));//["o", "v", "h", "i", "n", "e", "s", "e", "_", "f", "o", "o"]
       		console.log("I love chinese$food".match(reg2));//["o", "v", "h", "i", "n", "e", "s", "o", "o"]
       		console.log("I love chinese的food".match(reg2));//["o", "v", "h", "i", "n", "e", "s", "o", "o"]       		
       </script>

二十三 \cx	
       匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为字符一个原义的 'c' 字符。
       1 控制字符表
         http://baike.baidu.com/view/1112575.htm?fr=aladdin
       2 ASCII码表
         http://baike.baidu.com/link?url=9AsyJ-guFHp55UHgGDE91PxrdZtC7VJ0ML4fkjJcBRqNiS4ITdn1ZsAhnRCPgE__CRWmxTCHhDmioIPAQo0h6_
       3 转移字符表
         http://baike.baidu.com/link?url=VXReSb6oWSDjTuL3aGj5-4LbpG5X1aNuLu_8RNTt1I0uTH9zyC7WlXIlVubQlr6_ZpG40frEj_JzIdPknSvtBa
       在ASCII码中，第0～31号及第127号(共33个)是控制字符或通讯专用字符
       仅列举下列6个最常用的控制字符
       <script type="text/javascript">   
            //1 回车\r
            var reg1 = /^\cM$/;    		
       		console.log(reg1.test("\r"));//true
       		console.log(reg1.test("\x0d"));//true
       		console.log(reg1.test("\cM"));//false
       		//2 换行\n
       		var reg2 = /^\cJ$/;    		
       		console.log(reg2.test("\n"));//true
       		console.log(reg2.test("\x0a"));//true
       		console.log(reg2.test("\cJ"));//false     
       		//3 换行\f
       		var reg3 = /^\cL$/;    		
       		console.log(reg3.test("\f"));//true
       		console.log(reg3.test("\x0c"));//true
       		console.log(reg3.test("\cL"));//false     
       		//4 水平制表符\t	               
       		var reg4 = /^\cI$/;    		
       		console.log(reg4.test("\t"));//true
       		console.log(reg4.test("\x09"));//true
       		console.log(reg4.test("\cI"));//false     
            //5 垂直制表符\v	
            var reg5 = /^\cK$/;    		
       		console.log(reg5.test("\v"));//true
       		console.log(reg5.test("\x0b"));//true
       		console.log(reg5.test("\cK"));//false   
       	    //6 退格\b	
            var reg6 = /^\cH$/;    		
       		console.log(reg6.test("\b"));//true
       		console.log(reg6.test("\x08"));//true
       		console.log(reg6.test("\cH"));//false  
       		 //7 响铃\a	
            var reg7 = /^\cG$/;    		
       		console.log(reg7.test("\a"));//true
       		console.log(reg7.test("\x07"));//true
       		console.log(reg7.test("\cG"));//false                           
       </script>

二十四 \d	
       匹配一个数字字符。等价于 [0-9]。
       <script type="text/javascript">
       		var reg1 =/^\d$/;
       		console.log(reg1.test("1"));//true
       		console.log(reg1.test("a"));//false
       		console.log(reg1.test("1a"));//false,正则中只有一个字符，字符串有两个字符所以为false
       </script>

二十五 \D	
       匹配一个非数字字符。等价于 [^0-9]。
        <script type="text/javascript">
       		var reg1 =/^\d$/;
       		console.log(reg1.test("1"));//false
       		console.log(reg1.test("a"));//true
       		console.log(reg1.test("1a"));//false,正则中只有一个字符，字符串有两个字符所以为false
       </script>

二十六 \f	
       匹配一个换页符。等价于 \x0c 和 \cL。
       <script type="text/javascipt">
       		var reg1 = /^\f$/;
       		console.log(reg1.test("\f"));//true
       		console.log(reg1.test("\x0c"));//true
       		console.log(reg1.test("\cL"));//false     
       </script>

二十七 \n	
       匹配一个换行符。等价于 \x0a 和 \cJ。
       <script type="text/javascript">
       		var reg1 = /^\n$/;
       		console.log(reg1.test("\n"));//true
       		console.log(reg1.test("\x0a"));//true
       		console.log(reg1.test("\cJ"));//false     
       </script>

二十八 \r	
       匹配一个回车符。等价于 \x0d 和 \cM。
       <script type="text/javascript">
       		var reg1 = /^\r$/;
       		console.log(reg1.test("\r"));//true
       		console.log(reg1.test("\x0d"));//true
       		console.log(reg1.test("\cM"));//false
       </script>

二十九 \s	
       匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
       <script type="text/javascript">
       		var reg1 = /^\s$/;
       		console.log(reg1.test("\r"));//true
       		console.log(reg1.test("\x0d"));//true，\r的十六进制表示
       		console.log(reg1.test("\n"));//true
       		console.log(reg1.test("\x0a"));//true，\n的十六进制表示
       		console.log(reg1.test("\f"));//true
       		console.log(reg1.test("\x0c"));//true，\f的十六进制表示
       		console.log(reg1.test("\t"));//true
       		console.log(reg1.test("\x09"));//true，\t的十六进制表示
       		console.log(reg1.test("\v"));//true
       		console.log(reg1.test("\x0b"));//true，\v的十六进制表示
       		console.log(reg1.test(" "));//true
       		console.log(reg1.test("  "));//false, 正则中匹配一个空白字符，字符串中有两个空字符数量不匹配
       		console.log(reg1.test(""));//false，正则中匹配一个空白字符，字符串中没有字符数量不匹配
       		console.log(reg1.test("1"));//false
       		console.log(reg1.test("a"));//false
       		console.log(reg1.test("@"));//false
       </script>

三十  \S	
       匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
       <script type="text/javascript">
       		var reg1 = /^\S$/;
       		console.log(reg1.test("\r"));//false
       		console.log(reg1.test("\x0d"));//false，\r的十六进制表示
       		console.log(reg1.test("\n"));//false
       		console.log(reg1.test("\x0a"));//false，\n的十六进制表示
       		console.log(reg1.test("\f"));//false
       		console.log(reg1.test("\x0c"));//fasle，\f的十六进制表示
       		console.log(reg1.test("\t"));//false
       		console.log(reg1.test("\x09"));//false，\t的十六进制表示
       		console.log(reg1.test("\v"));//false
       		console.log(reg1.test("\x0b"));//false，\v的十六进制表示
       		console.log(reg1.test(" "));//false
       		console.log(reg1.test("  "));//false, 正则中匹配一个非空白字符，字符串中有两个空字符数量和内容不匹配
       		console.log(reg1.test(""));//false，正则中匹配一个非空白字符，字符串中没有字符数量不匹配
       		console.log(reg1.test("1"));//true
       		console.log(reg1.test("a"));//true
       		console.log(reg1.test("@"));//trure

三十一 \t 
       匹配一个制表符。等价于 \x09 和 \cI。
        <script type="text/javascript">
          var reg1 = /^\t$/;
          console.log(reg1.test("\t"));//true
          console.log(reg1.test("\x09"));//true
          console.log(reg1.test("\cI"));//false
       </script>

三十二 \v 
      匹配一个垂直制表符。等价于 \x0b 和 \cK。
       <script type="text/javascript">
          var reg1 = /^\v$/;
          console.log(reg1.test("\v"));//true
          console.log(reg1.test("\x0b"));//true
          console.log(reg1.test("\cK"));//false
       </script>

三十三 \w 
      匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
      <script type="text/javascript">
        var reg1 = /^\w$/;
        console.log(reg1.test("a"));//true
        console.log(reg1.test("A"));//true
        console.log(reg1.test("0"));//true
        console.log(reg1.test("_"));//true
        console.log(reg1.test("-"));//false
        console.log(reg1.test("@"));//false
      </script>      

三十四 \W 
      匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
      <script type="text/javascript">
          var reg1 = /^\W$/;
          console.log(reg1.test("a"));//false
          console.log(reg1.test("A"));//fasle
          console.log(reg1.test("0"));//false
          console.log(reg1.test("_"));//false
          console.log(reg1.test("-"));//true
          console.log(reg1.test("@"));//true
      </script>

三十五 \xn  
    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， '\x41' 匹配"A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。.
    ASCII码表
         http://baike.baidu.com/link?url=9AsyJ-guFHp55UHgGDE91PxrdZtC7VJ0ML4fkjJcBRqNiS4ITdn1ZsAhnRCPgE__CRWmxTCHhDmioIPAQo0h6_
    \x后的两位数字对应ASCII码表十六进制编码对应字符
    <script type="text/javascript">
        var reg1 = /\x41/; //十六制41表示十进制65，对应的ASCII字符是A       
        console.log(reg1.test("A"));//true
        console.log(reg1.test("65"));//false
        console.log(reg1.test("\0x41"));//false
        var reg2 = /\x411/;
        console.log(reg2.test("A1"));//true
        console.log(reg2.test("651"));//false
        console.log(reg2.test("\0x411"));//false
    </script>false

三十六 \num 
    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
    分组引用，最常用场景用来就对称数 ，回文 。
    <script type="text/javascript">
        var reg1 = /^(.)\1$/;
        console.log(reg1.test("aa"));//true
        console.log(reg1.test("##"));//true
        console.log(reg1.test("ab"));//false
        var reg2= /^(.)(.)(.).\3\2\1$/;
        console.log(reg2.test("处处飞花飞处处"));//true
        console.log(reg2.test("凤落梧桐梧落凤"));//true
        console.log(reg2.test("风送花香红满地"));//false
    </script>  

三十七 \n 
    标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)
    向后引用见第36
    <script type="text/javascript"> 
        //1 向后引用,因为\2前面有2个引用分组，所以\2表示第2个分组，    
        var reg1= /^(.)(.)\2$/;
        console.log(reg1.test("abb"));//true
        console.log(reg1.test("@##"));//true
        console.log(reg1.test("ab3"));//false
        //2 向后引用,因为\2前面有2个引用分组，所以\2表示第2个分组，    
        var reg2= /^(.)(.)\3$/;
        console.log(reg2.test("abb"));//false
        console.log(reg2.test("@##"));//fasle
        console.log(reg2.test("ab3"));//false
        console.log(reg2.test("ab"));//false
        console.log(reg2.test("ab03"));//false
        console.log(reg2.test("ab\03"));//true
    </script>

38 \nm  
   标识一个八进制转义，则 n 为一个八进制转义值。值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若  n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
    向后引用见第36
    <script type="text/javascript"> 
        //1 向后引用,因为\12前面有12个分组，所以\2表示第12个分组，    
        var reg1= /^(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\12$/;
        console.log(reg1.test("abcdefghijkll"));//true
        console.log(reg1.test("0123456789@##"));//true
        console.log(reg1.test("0123456789abc"));//false
         //2 向后引用,因为一共只有12个分组，82超出范围12，而第一个数字8超出8进制范围，所以\82匹配字符串"82" 
        var reg2= /^(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\82$/;
        console.log(reg2.test("abcdefghijklh2"));//false
        console.log(reg2.test("0123456789@#72"));//false
        console.log(reg2.test("0123456789ab82"));//true
         //3 向后引用,因为\82前面有8个分组，22超出范围12，而第一个数字2在8进制范围以内，所以\22匹配八进制字符串"\022"  
        var reg3= /^(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\22$/;
        console.log(reg3.test("abcdefghijklb2"));//false
        console.log(reg3.test("0123456789@#12"));//false
        console.log(reg3.test("0123456789ab22"));//false
        console.log(reg3.test("0123456789ab18"));//false
        console.log(reg3.test("0123456789ab022"));//fasle
        console.log(reg3.test("0123456789ab\022"));//true
         //4 向后引用,因为\82前面有8个分组，28超出范围12，而第一个数字2在8进制范围以内，所以正则\28匹配八进制字符串"\028"  
        var reg4= /^(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\28$/;
        console.log(reg4.test("abcdefghijklb2"));//false
        console.log(reg4.test("0123456789@#12"));//false
        console.log(reg4.test("0123456789ab28"));//false
        console.log(reg4.test("0123456789ab24"));//false
        console.log(reg4.test("0123456789ab028"));//fasle
        console.log(reg4.test("0123456789ab\028"));//true
    </script>


39 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
   <script type="text/javascript">
      // 1 当 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)
      var reg1 = /^\377$/;
      console.log(reg1.test("377"));//fasle
      console.log(reg1.test("\377"));//true
      console.log(reg1.test("0377"));//false
      console.log(reg1.test("\0377"));//fasle
      console.log(reg1.test("255"));//fasle
      console.log(reg1.test("\255"));//fasle
      console.log(reg1.test("0xff"));//fasle
      console.log(reg1.test("\0xff"));//fasle
      //2 当 n 不是八进制数字 (0-3),则匹配字符串"\nml"和字符串"\0nml"
       var reg2 = false/^\477$/;
      console.log(reg2.test("477"));//fasle
      console.log(reg2.test("\477"));//true
      console.log(reg2.test("0477"));//
      console.log(reg2.test("\0477"));//true
      console.log(reg2.test("319"));//fasle
      console.log(reg2.test("\319"));//fasle
      console.log(reg2.test("0x13f"));//fasle
      console.log(reg2.test("\0x13f"));//fasle
   </script> 

40 \un  匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
   unicode转码工具http://tool.chinaz.com/tools/unicode.aspx
  <script type="text/javascript">
      //1  匹配某个Unicode字符
      var reg1 = /^\u66f9$/; //\u66f9对应中文"曹"
      console.log(reg1.test("曹"));//true
      console.log(reg1.test("操"));//false   
      //2 匹配某种Unicode字符，比如匹配所有中文
      var reg2 = /^[\u4e00-\u9fa5]$/; //[\u4e00-\u9fa5对应全部中文
      console.log(reg2.test("曹"));//true
      console.log(reg2.test("操"));//true  
  </script>

      
	</pre>
  </body>
</html>
