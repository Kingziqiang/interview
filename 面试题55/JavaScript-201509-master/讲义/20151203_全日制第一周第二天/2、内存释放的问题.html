<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //堆内存释放的问题->堆内存用来存储引用数据类型值的
    //[谷歌]
    //浏览器会每隔一段时间,看我们的堆内存是否还有其他的东西引用着,如果还在被占用着,浏览器不会进行处理；但是如果我们的堆内存已经没有任何的东西占用了,那么浏览器会把这个堆内存进行回收释放
    //[IE和火狐]
    //开辟了一个堆内存,我们有一个占用的时候浏览器记一个数(记录有多少个占用这个内存),当我们减少引用的时候,浏览器会把记数减1,当记的数字减为0的时候,浏览器会把我们的堆内存回收释放

    //    var obj = {name: "于治", age: 19};
    //    var obj2 = obj;
    //    obj = null;//null:空对象指针
    //    obj2 = null;

    //[优化]
    //对于堆内存的释放,我们在JS代码编写的时候,对于没有用的堆内存,我们手动给变量赋值为null,来取消所有对这个堆内存的占用,这样浏览器就可以把没有被占用的堆内存进行回收释放...


    //栈内存释放的问题->是用来提供JS代码执行环境的
    //[window全局作用域]
    //全局作用域在打开当前页面的时候就会生成，只有在关闭当前页面后全局作用域才会销毁 ->全局作用域属于不销毁的作用域

    //[私有作用域]
    //1)一般情况下,函数执行会形成一个私有的作用域,接下来在私有的作用域中完成：形参赋值->预解释->代码从上到下执行,当代码执行完成后我们当前形成这个私有的作用域会"立即销毁";
    //2)函数执行形成一个私有的作用域(A),如果A中的某些内容,被A以外的东西占用了,那么A这个私有作用域就"不能销毁了"; ->如果A这个作用域不销毁,那么它里面的私有变量等都不会销毁;
    //具体的形式:
    //函数执行的时候返回了一个引用数据类型的值,并且在函数的外面用一个其他的东西把返回值接收了;例如:fn

    var total = 100;
    function fn() {
        var total = 10;
        return function () {
            console.log(total);
        };
    }
    var f = fn();
    f();
    f();
    f();
</script>
</body>
</html>