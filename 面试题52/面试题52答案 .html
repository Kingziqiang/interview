<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>面试题52答案</title>    
</head>
<body>
	<h1>52 什么是闭包？预解释的机制？在作用域链中查找私有变量的过程？如何判断上一级作用域是谁？作用域的销毁机制？利用属性和闭包等多种方法实现投票计数器，分析每种方法的优劣？</h1>
	<pre>	
一、什么是闭包？
  当一个方法在运行的时候，就会形成一个私有的作用域，在这个作用域里，里面定义的变量不会受到上一级作用域或其它作用域的影响，不会和全局或其它作用域里的变量有冲突。
  这个由方法运行而产生的私有作用域，就叫闭包。
  我们应该把闭包理解为函数运行机制，而不是某种形式。

二、预解释的机制
	1、不管判断的条件是否成立，判断体中的代码也要进行预解释。
  2、只对"="左边的进行预解释，"="右边的不进行预解释
  3、自执行函数在window下不进行预解释的，但是当代码执行到这块的时候，自执行函数执行，会形成一个私有的作用域，在私有作用域中要进行预解释
  4、函数体中，return返回的值是不进行预解释的，但是虽然return后面的代码不在执行了，但是需要进行预解释
  5、在预解释的时候，如果发现了重复名字的，我们不进行重新的声明，但是我们需要重新的定义赋值

三、在作用域链中查找私有变量的过程
     1 搜索过程从作用域链的前端开始，向上（外部环境）逐级查询与给定名字匹配的标识符。         
       2 如果在局部环境中找到了该标识符。搜索过程停止，变量就绪。
          <script type="text/javascript">               
        function outer(){         
            function inner(){
               var innerVar="inner";
               console.log(innerVar); //inner 在当前作用域(作用域前端）中找到变量名innerVar
            }           
            inner();
        }       
        outer();
         </script>
       3 如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。
         <script type="text/javascript">             
        function outer(){
            var outerVar = "outer";
            function inner(){
               console.log(outerVar); //outer  在上级作用域中找到变量名outerVar
            }           
            inner();
        }       
        outer();
         </script>
       4 如果局部环境中一直没有找到该变量名，在搜索过程一直追溯到全部环境的变量对象。
         <script type="text/javascript">
                var globalVar = "global";
        function outer(){          
            function inner(){
               console.log(globalVar); //global 在全局环境中找到变量名globalVar
            }           
            inner();
        }       
        outer();
         </script>
       5 如果在全部环境中也没有找到该标识符，则意味着该变量尚未声明。
         <script type="text/javascript">            
        function outer(){          
            function inner(){
               console.log(globalVar); //报错“globalVar is not defined” 从前端到全局环境整个作用域链中都没有找到变量名globalVar
            }           
            inner();
        }       
        outer();
         </script>

四、如何判断上一级作用域是谁  
	它的上级作用域是谁，和在哪执行的没有关系，只和在哪定义的有关系(它所对应的堆内存是在哪定义的，那么它的上级作用域就是谁)
  1 如果当前作用域是windows全局作用域，则没有上级作用域
  2 如果当前作用域对应的函数inner定义在windows全局作用域（脚本而非函数）中，则上级作用域是windows全局作用域。
  3 如果当前作用域对应的函数inner定义在函数outer的函数体中，则上级作用域是outer函数执行时对应的私有作用域。
  特殊情况：参见面试题43答案，如何延长作用域链
  4 如果当前作用域对应的函数inner定义在函数with语句体中，则上级作用域是with语句对应的私有作用域。
  5 如果当前作用域对应的函数inner定义在函数catch语句体中，catch语句并未形成私有作用域，仅仅catch参数（假设参数名为e)的同名变量受影响。


五、作用域的销毁机制
    1 作用域的销毁
      一般情况下，函数执行形成一个私有的作用域，当执行完成后就销毁了->节省内存空间
    2 作用域的不立即销毁
      function fn(){
        var i=10;
        return function(n){
        console.log(n+i++);
        }
      }
      fn()(15);//->先执行fn,有一个私有的变量i=10,返回一个堆内存地址 xxxfff111,我们发现这个地址还用到了一次,那么当前的这个fn形成私有作用域（A）就不能立即销毁了,xxxfff111(15)->输出25,A中的i变为11；当xxxfff111执行完了,发现这个地址没用了,浏览器就把A、xxxfff111都释放了
      fn()(20);//->在执行fn的时候一切都从新开始了,和上面的步骤是一样的->输出30
    3 作用域的不销毁：形成一个私有作用域,里面的内容被外面占用了
      function fn(){
        var i=10;
        return function(n){
        console.log(n+i++);
        }
      }
      var f=fn();//->fn执行形成一个私有的作用域A,A中有一个私有的变量i=10,A中返回一个地址xxxfff11,被外面的f占用了,那么当前的A就不能销毁了
      f(15);//->输出25,让A中的i=11
      f(20);//->输出31,让A中的i=12
      ...
      当我们知道f用完的时候,为了优化性能,我们让f=null,这样的话A中的xxxfff111没人占用了,浏览器会把A和xxxfff111都释放了

六 几种不销毁常用到的形式:
  1 函数执行,返回一个引用数据类型的值,并且在函数的外面被别人接收了,那么当前函数形成的私有作用域就不在销毁了-->例如上面的案例
  2 在函数执行的时候,里面的一个小函数的地址赋值给了我们的外面元素的点击事件,那么当前小函数也相当于被外面占用了,大函数执行形成的私有的作用域也不销毁了
    每一次循环都执行自执行函数形成一个私有的作用域(循环三次就有三个作用域,每一个作用域中都有一个i,第一个存储的是0,第二个存数的是1..)，在每一个私有的作用域中都把里面的函数绑定给了外面元素的点击事件,这样的话每一次形成的作用域都不销毁了(三个不销毁的作用域)
    var oLis=document.getElementsByTagName("li");
    for(var i=0;i<oLis.length;i++){
      ~function(i){
        oLis[i].onclick=function(){
          tabChange(i);
        }
      }(i);
    }
  3 在使用setTimeout实现轮询动画的时候,我们如果move需要传递参数值,那么像下面这样的写法会行成很多的不销毁的作用域,非常的耗性能
    function move(tar){ 
        //window.setTimeout(move,10); ->第二次执行move的时候我们没有给它传值(这样写不行)
        window.setTimeout(function(){
            move(tar);
        },10);//->这样写实现了,但是每一次执行定时器都会形成一个私有的所用域(匿名函数形成的)A,在A中使用了上级作用域中的tar的值,而且执行了move又形成了一个小的作用域(而在小的作用域中会使用tar的值),这样每一次定时器形成的A都不能销毁了
    }
    move(100);//->第一次这样执行传递100
    //解决办法:
    function move(tar){
        ~function _move(){    
            window.setTimeout(_move,10);
        }();
    }
    move(100);//->第一次这样执行传递100


七、JS中内存空间释放的问题（堆内存、栈内存）
    1 [谷歌浏览器]
      我们开辟一个内存，可能或有一些其他的变量等占用了这个内存，谷歌浏览器都会间隔一段时间看这个内存还有没有被占用，如果发现有没有被占用的内存了，就自己帮我们回收了(内存释放)
    2 [火狐和IE]
      我们开个内存，当我们引用了它，就在内存中记录一个数,增加一个引用浏览器就把这个数+1，减少一个引用，浏览器就把这个数-1...当减到零的时候浏览器就把这个内存释放了;但是有些情况下(尤其是IE)记着记着就弄乱了，内存就不能释放了-->浏览器的内存泄露
    3 手动释放内存
      var obj={};
      我们养成一个好的习惯，当我们obj这个对象使用完成了，我们手动的obj=null (null空对象指针)，浏览器会自己把刚才的堆内存释放掉

八、利用属性和闭包等多种方法实现投票计数器，分析每种方法的优劣？
    参考上面五、六、七大题关于作用域的销毁机制和内存释放问题
     详见《计数器（增加第6种写法行内js).html》
     1 第1种写法会造成全局变量污染，不推荐
     2 第2中写法自定义属性，可以将值一直保存下来，推荐。
     3 第3种写法闭包产生不销毁的私有作用域，每次点击都产生新的不销毁的私有作用域，占用堆内存空无法释放。不推荐
     4 第4种写法闭包产生不销毁的私有作用域，每次点击都产生新的不销毁的私有作用域，占用堆内存空无法释放。不推荐
     5 利用innerHTML属性即可以设置，推荐。
     6 第6种写法行内js，不安全，因此不推荐。
     综上推荐第2中和第5中写法，第2种写法较为常见，第5种写法应用于特定场景（改变元素的内置属性值时）